import{_ as e,o as s,c as a,N as n}from"./chunks/framework.0e180df0.js";const C=JSON.parse('{"title":"Module guppy","description":"","frontmatter":{},"headers":[],"relativePath":"cours/python/optimisation/mesure-de-performance/module-guppy/index.md"}'),l={name:"cours/python/optimisation/mesure-de-performance/module-guppy/index.md"},o=n(`<h1 id="module-guppy" tabindex="-1">Module guppy <a class="header-anchor" href="#module-guppy" aria-label="Permalink to &quot;Module guppy&quot;">​</a></h1><p>Enfin, une autre possibilité pour obtenir de l&#39;information sur la consommation mémoire consiste à utiliser le <em>module <code>guppy</code></em>. Ce dernier contient notamment un sous-module d&#39;analyse du contenu du <em>tas</em>. Ce sous-module, dénommé <i>Heapy</i>, est plutôt complexe à apprendre, mais il est néanmoins possible de facilement réaliser de simples analyses.</p><h2 id="analyse-du-tas" tabindex="-1">Analyse du tas <a class="header-anchor" href="#analyse-du-tas" aria-label="Permalink to &quot;Analyse du tas&quot;">​</a></h2><p>Pour effectuer une analyse du tas, il faut d&#39;abord créer un contexte de session avec la <em>fonction <code>hpy</code></em>. On peut ensuite créer une capture de tous les objets qui sont accessibles en RAM avec la méthode <code>heap</code>. Voici un simple exemple d&#39;utilisation du module <code>guppy</code> :</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> guppy </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> hpy</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">hp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hpy</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#82AAFF;">print</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">hp</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">heap</span><span style="color:#89DDFF;">())</span></span></code></pre></div><p>En observant le résultat de l&#39;exécution, on se rend compte que, sans avoir rien fait de particulier, il y a déjà une multitude d&#39;objets créés en mémoire. Le résultat montre, par exemple, qu&#39;il y a déjà 11.116 objets de type <code>str</code> en mémoire, ce qui représente 31% de la mémoire totale utilisée, soit 997.255 octets des 4.570.543 octets utilisés.</p><p>On peut voir le même type d&#39;information pour toute une série d&#39;autres types d&#39;objet, chaque ligne du résultat rassemblant précisément l&#39;information collectée pour tous les objets d&#39;un même type :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Partition of a set of 35935 objects. Total size = 4570543 bytes.</span></span>
<span class="line"><span style="color:#A6ACCD;"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span></span>
<span class="line"><span style="color:#A6ACCD;">     0  11116  31   997255  22    997255  22 str</span></span>
<span class="line"><span style="color:#A6ACCD;">     1   7081  20   491872  11   1489127  33 tuple</span></span>
<span class="line"><span style="color:#A6ACCD;">     2   2518   7   444728  10   1933855  42 types.CodeType</span></span>
<span class="line"><span style="color:#A6ACCD;">     3   4988  14   350056   8   2283911  50 bytes</span></span>
<span class="line"><span style="color:#A6ACCD;">     4    446   1   346896   8   2630807  58 type</span></span>
<span class="line"><span style="color:#A6ACCD;">     5   2327   6   316472   7   2947279  64 function</span></span>
<span class="line"><span style="color:#A6ACCD;">     6      2   0   262480   6   3209759  70 _io.BufferedWriter</span></span>
<span class="line"><span style="color:#A6ACCD;">     7    446   1   243480   5   3453239  76 dict of type</span></span>
<span class="line"><span style="color:#A6ACCD;">     8     97   0   164832   4   3618071  79 dict of module</span></span>
<span class="line"><span style="color:#A6ACCD;">     9      1   0   131240   3   3749311  82 _io.BufferedReader</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;115 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span></span></code></pre></div><p>Pour mesurer la consommation de mémoire résultant de l&#39;exécution d&#39;une partie de programme uniquement, il faut réaliser une capture avant et après la partie de programme d&#39;intérêt.</p><p>Néanmoins, contrairement au module <code>tracemalloc</code>, il n&#39;est pas possible de facilement comparer deux captures avec le module <code>guppy</code>. Pour réaliser une telle analyse, ce qu&#39;il faut donc faire, c&#39;est réinitialiser la surveillance de la mémoire avec la méthode <code>setrelheap</code>. Ainsi, la prochaine capture réalisée contiendra uniquement les objets créés en mémoire à partir de l&#39;appel à cette méthode jusqu&#39;à l&#39;appel à la méthode <code>heap</code>.</p><p>L&#39;exemple suivant illustre comment réaliser une telle analyse, de la consommation mémoire d&#39;une partie de programme uniquement :</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">hp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hpy</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">hp</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setrelheap</span><span style="color:#89DDFF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">range</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">)]</span></span>
<span class="line"><span style="color:#A6ACCD;">labels </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">str</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">i</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> data</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">print</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">hp</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">heap</span><span style="color:#89DDFF;">())</span></span></code></pre></div><p>Comme on peut le voir sur le résultat de l&#39;exécution, il y a exactement 100 objets de type <code>str</code>, 100 objets de type <code>float</code>, 2 objets de type <code>list</code> et enfin 1 objet de type <code>types.FrameType</code>, qui ont été créés dans le tas, suite à l&#39;exécution des deux instructions qui ont créé les deux objets respectivement référencés par les variables <code>data</code> et <code>labels</code> :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Partition of a set of 203 objects. Total size = 9816 bytes.</span></span>
<span class="line"><span style="color:#A6ACCD;"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span></span>
<span class="line"><span style="color:#A6ACCD;">     0    100  49     5200  53      5200  53 str</span></span>
<span class="line"><span style="color:#A6ACCD;">     1    100  49     2400  24      7600  77 float</span></span>
<span class="line"><span style="color:#A6ACCD;">     2      2   1     1808  18      9408  96 list</span></span>
<span class="line"><span style="color:#A6ACCD;">     3      1   0      408   4      9816 100 types.FrameType</span></span></code></pre></div><p>Contrairement aux analyses que l&#39;on a pu faire dans les sections précédentes, les informations que l&#39;on obtient avec le module <code>guppy</code> sont bien plus précises et concernent uniquement la mémoire allouée dans le tas, et pas ce qui se trouve dans la pile, comme les variables locales.</p><h2 id="relation-d-equivalence" tabindex="-1">Relation d&#39;équivalence <a class="header-anchor" href="#relation-d-equivalence" aria-label="Permalink to &quot;Relation d&#39;équivalence&quot;">​</a></h2><p>Par défaut, la méthode <code>heap</code> rassemble, dans son résultat, tous les objets qu&#39;elle a capturés dans la mémoire en suivant la relation d&#39;équivalence <i>« Clodo »</i> (<i>Class or dict owner</i>). Selon cette relation, tous les objets provenant de la même classe ou du même dictionnaire sont repris dans une même ligne du résultat.</p><p>D&#39;autres relations d&#39;équivalence peuvent être utilisées, notamment <code>bytype</code> qui rassemble les objets par type et <code>byrcs</code> qui les rassemble selon les types des objets ayant une référence vers eux. En repartant de la capture mémoire faite dans la section précédente, on peut en savoir plus sur les objets <i>« conteneurs »</i> avec :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">print(h.byrcs)</span></span></code></pre></div><p>La partition obtenue avec cette instruction montre que 200 des objets du tas sont référencés par des objets de type <code>list</code>, que deux sont référencés par le dictionnaire du module et qu&#39;un n&#39;est pas référencé :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Partition of a set of 203 objects. Total size = 9816 bytes.</span></span>
<span class="line"><span style="color:#A6ACCD;"> Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)</span></span>
<span class="line"><span style="color:#A6ACCD;">     0    200  99     7600  77      7600  77 list</span></span>
<span class="line"><span style="color:#A6ACCD;">     1      2   1     1808  18      9408  96 dict of module</span></span>
<span class="line"><span style="color:#A6ACCD;">     2      1   0      408   4      9816 100 &lt;Nothing&gt;</span></span></code></pre></div><p>Le <em>dictionnaire de module</em>, accessible avec la fonction <code>globals</code>, contient toutes les variables globales déclarées dans le module. C&#39;est la raison pour laquelle les objets référencés par les variables <code>data</code> et <code>labels</code> y sont également référencés.</p><p>On peut raffiner l&#39;analyse précédente en identifiant, par exemple, les types des objets référencés par des objets de type <code>list</code>, avec :</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">print</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">h</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">byrcs</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">].</span><span style="color:#F07178;">byclodo</span><span style="color:#89DDFF;">)</span></span></code></pre></div><p>La partition obtenue avec cette instruction montre que, parmi les 200 objets référencés par des listes, et comme on avait déjà pu l&#39;observer précédemment, il y a 100 objets de type <code>str</code> et 100 de type <code>float</code> :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Partition of a set of 200 objects. Total size = 7600 bytes.</span></span>
<span class="line"><span style="color:#A6ACCD;"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span></span>
<span class="line"><span style="color:#A6ACCD;">     0    100  50     5200  68      5200  68 str</span></span>
<span class="line"><span style="color:#A6ACCD;">     1    100  50     2400  32      7600 100 float</span></span></code></pre></div><p>Il y a encore beaucoup d&#39;autres possibilités permettant des analyses très poussées avec le module <code>guppy</code>, mais elles sortent du cadre de ce livre.</p>`,27),t=[o];function p(c,r,i,d,u,y){return s(),a("div",null,t)}const A=e(l,[["render",p]]);export{C as __pageData,A as default};
