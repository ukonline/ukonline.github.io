import{_ as s,o as e,c as n,N as a}from"./chunks/framework.0e180df0.js";const d=JSON.parse(`{"title":"Gestion d'erreur","description":"","frontmatter":{},"headers":[],"relativePath":"cours/python/optimisation/expression-idiomatique/gestion-d-erreur/index.md"}`),o={name:"cours/python/optimisation/expression-idiomatique/gestion-d-erreur/index.md"},l=a(`<h1 id="gestion-d-erreur" tabindex="-1">Gestion d&#39;erreur <a class="header-anchor" href="#gestion-d-erreur" aria-label="Permalink to &quot;Gestion d&#39;erreur&quot;">​</a></h1><p>La <em>gestion des erreurs</em> est une activité importante quand on rédige un programme que l&#39;on souhaite le plus robuste possible. De manière générale, il existe deux approches pour gérer les erreurs dans un programme.</p><p>La première approche, appelée <em>LBYL</em> (<i>Look Before You Leap</i>), consiste à explicitement vérifier que toutes les préconditions sont bien satisfaites avant d&#39;exécuter un code. C&#39;est, par exemple, l&#39;approche utilisée en C ou en Go.</p><p>L&#39;autre approche, appelée <em>EAFP</em> (<i>Easier to Ask for Forgiveness than Permission</i>), et préconisée en Python, consiste à supposer que les hypothèses sont satisfaites et à gérer les éventuelles erreurs avec le <em>mécanisme d&#39;exception</em>, à savoir <code>try-except</code> en Python.</p><h2 id="acces-a-un-dictionnaire" tabindex="-1">Accès à un dictionnaire <a class="header-anchor" href="#acces-a-un-dictionnaire" aria-label="Permalink to &quot;Accès à un dictionnaire&quot;">​</a></h2><p>Accéder au contenu d&#39;un dictionnaire se fait essentiellement à partir des clés des paires clé-valeur contenues dans le dictionnaire. Voici deux fonctions qui permettent de compter les fréquences d&#39;apparition des lettres présentes dans un mot :</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">frequencies_1</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">word</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    freq </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> word</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">not</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> freq</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            freq</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#A6ACCD;">        freq</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> freq</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">frequencies_2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">word</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    freq </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> word</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            freq</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">except</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">KeyError</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            freq</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> freq</span></span></code></pre></div><p>La première fonction vérifie systématiquement si la lettre est présente ou non comme clé dans le dictionnaire et, si ce n&#39;est pas le cas, rajoute cette clé en lui associant la valeur 0. On est clairement dans une approche LBYL et ce type de code n&#39;est pas du tout <i>« pythonique »</i>.</p><p>La seconde fonction, qui suit l&#39;approche EAFP, est beaucoup plus courante en Python. Elle accède systématiquement à la clé dans le dictionnaire pour incrémenter la valeur associée et, si une exception de type <code>KeyError</code> se produit, rajoute la clé manquante dans le dictionnaire en lui associant la valeur 1.</p><p>Au niveau des performances, le fait d&#39;utiliser un <code>try-except</code> n&#39;est pas pénalisant, les deux fonctions prenant 106 ms pour s&#39;exécuter avec une chaine de caractères aléatoire de cent-mille lettres minuscules. L&#39;approche EAFP sera parfois plus rapide, en fonction de la complexité de la condition du <code>if</code> utilisée dans l&#39;approche LBYL.</p><h2 id="expression-reguliere" tabindex="-1">Expression régulière <a class="header-anchor" href="#expression-reguliere" aria-label="Permalink to &quot;Expression régulière&quot;">​</a></h2><p>Voyons un autre exemple où l&#39;utilisation d&#39;un <code>try-except</code> est bien plus rapide que le test équivalent à l&#39;aide d&#39;un <code>if</code>, car la condition de ce dernier est complexe et prend beaucoup de temps à évaluer.</p><p>Voici deux fonctions qui permettent de calculer la somme des nombres entiers se trouvant dans une liste de chaine de caractères :</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sumtextint_1</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> d </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> data</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> re</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">^[1-9][0-9]*$</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> d</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">            result</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">int</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">d</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sum</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">result</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sumtextint_2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> d </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#A6ACCD;"> data</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            result</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">int</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">d</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">except</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ValueError</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">pass</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sum</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">result</span><span style="color:#89DDFF;">)</span></span></code></pre></div><p>La première fonction vérifie, à l&#39;aide d&#39;une expression régulière, que l&#39;on a bien un nombre entier qui pourra donc être converti sans erreur en un nombre de type <code>int</code>. La seconde fonction fait l&#39;hypothèse que l&#39;on a bien des nombres entiers en convertissant directement les éléments de la liste reçue en paramètre. Si ce n&#39;est pas le cas, la fonction traite la situation exceptionnelle en utilisant le mécanisme d&#39;exception avec un <code>try-except</code>, en capturant une exception de type <code>ValueError</code>.</p><p>La seconde fonction est beaucoup plus rapide que la première. En effet, on passe de 250 ms à 67 ms pour calculer la somme des éléments d&#39;une liste de cent-mille nombres représentés par des chaines de caractères, soit une diminution de temps de 73%.</p>`,16),p=[l];function t(r,c,i,y,D,F){return e(),n("div",null,p)}const u=s(o,[["render",t]]);export{d as __pageData,u as default};
