import{_ as e,o as s,c as t,N as r}from"./chunks/framework.0e180df0.js";const g=JSON.parse('{"title":"Profilage","description":"","frontmatter":{},"headers":[],"relativePath":"cours/python/optimisation/audit-de-code/profilage/index.md"}'),i={name:"cours/python/optimisation/audit-de-code/profilage/index.md"},o=r('<h1 id="profilage" tabindex="-1">Profilage <a class="header-anchor" href="#profilage" aria-label="Permalink to &quot;Profilage&quot;">​</a></h1><p>Pour optimiser un programme et le rendre plus rapide, ou moins gourmand au niveau de sa consommation mémoire, il faut d&#39;abord <em>profiler</em> son exécution. Ce profilage a pour objectif d&#39;identifier quels sont les portions du programme qui sont particulièrement lentes ou consommatrices de mémoire. Ce sont, en effet, ces goulots d&#39;étranglement qu&#39;il faut traiter et optimiser, en premier lieu.</p><h2 id="methode-de-profilage" tabindex="-1">Méthode de profilage <a class="header-anchor" href="#methode-de-profilage" aria-label="Permalink to &quot;Méthode de profilage&quot;">​</a></h2><p>Il y a essentiellement deux <em>méthodes de profilage</em> d&#39;un programme qu&#39;il est possible d&#39;utiliser. Ces deux méthodes sont généralement utilisées de manière complémentaire, pour d&#39;abord rapidement réaliser une première analyse globale, ensuite suivie d&#39;une analyse locale plus poussée.</p><p>Lors d&#39;un <em>profilage déterministe</em>, toutes les occurrences d&#39;un ou plusieurs types d&#39;évènements qui se produisent lors de l&#39;exécution d&#39;un programme sont capturés. Ces évènements peuvent être des appels de fonction, l&#39;exécution d&#39;instructions <code>return</code>, etc. L&#39;avantage des méthodes déterministes est leur grande précision quant aux mesures réalisées. La contrepartie est la lourdeur du monitoring et le ralentissement du temps d&#39;exécution global du programme profilé. Ces méthodes ne sont pas envisageables en production, mais uniquement recommandées lors du développement et des tests. Une autre possibilité est de limiter leur utilisation à quelques petites fonctions, mais pas à un programme complet.</p><p>Lors d&#39;un <em>profilage statistique</em>, l&#39;exécution du programme est interrompue à intervalles réguliers afin que des échantillons de l&#39;état de l&#39;exécution puissent être capturés. Tous les échantillons qui ont été capturés sont ensuite analysés pour en déduire des indicateurs. L&#39;avantage des méthodes statistiques est qu&#39;elles n&#39;occasionnent que peu de surcharge au programme analysé. La contrepartie est la moins grande précision, par rapport aux méthodes déterministes.</p><h2 id="ressource" tabindex="-1">Ressource <a class="header-anchor" href="#ressource" aria-label="Permalink to &quot;Ressource&quot;">​</a></h2><p>Jusqu&#39;à présent, on a déjà présenté deux <em>métriques</em> qu&#39;il est possible d&#39;utiliser lorsque l&#39;on réalise un profilage de code. Les métriques sont généralement associées à une ressource que l&#39;on souhaite utiliser d&#39;une manière la plus économe possible.</p><p>Lorsque l&#39;on s&#39;intéresse au processeur, on va généralement utiliser le <em>temps processeur</em> comme métrique d&#39;intérêt. Si la ressource concernée est la mémoire vive, alors la métrique souvent utilisée est la <em>consommation mémoire</em> du code. D&#39;autres ressources de l&#39;ordinateur peuvent aussi être la cause de mauvaises performances observées lors de l&#39;exécution d&#39;un programme. Il est ainsi également possible de s&#39;intéresser <em>aux lectures et aux écritures de données</em> sur le disque ou sur l&#39;interface réseau.</p><h2 id="granularite" tabindex="-1">Granularité <a class="header-anchor" href="#granularite" aria-label="Permalink to &quot;Granularité&quot;">​</a></h2><p>Tant pour les méthodes de profilage déterministes que statistiques, les mesures peuvent être réalisées à différents niveaux. Si on prend comme exemple le temps d&#39;exécution, il est possible de le mesurer pour chaque ligne de code ou pour chaque fonction, par exemple. Le profilage d&#39;un programme permettrait alors d&#39;identifier les lignes de code ou les fonctions qui sont vraiment lentes. On peut également plutôt mesurer le nombre de fois qu&#39;une ligne de code ou qu&#39;une fonction est exécutée. Ceci permettrait à un audit de révéler les lignes de code ou fonctions qui sont très souvent exécutées, des potentielles opportunités d&#39;optimisation.</p><p>Outre les lignes de code et les fonctions, il est aussi possible de s&#39;intéresser à des mesures à d&#39;autres niveaux. On pourrait, par exemple, profiler les performances d&#39;une classe, d&#39;un module ou d&#39;un programme dans son entièreté. Au plus la granularité utilisée sera fine, au plus il sera possible d&#39;extraire de l&#39;information intéressante suite au profilage. Néanmoins, une analyse avec un niveau fin de granularité aura comme inconvénient l&#39;ajout de beaucoup de bruit, surtout en cas de profilage déterministe.</p><p>Le <em>choix de la granularité</em> doit aussi être fait en lien avec le type de programme analysé. En effet, dans le cas d&#39;un serveur web, par exemple, il sera difficile de s&#39;intéresser à la mesure du temps d&#39;exécution du programme, par exemple. L&#39;exécution d&#39;un serveur web ne se termine en effet pas. On va dès lors plutôt se tourner vers un profilage des fonctions ou lignes de code, par exemple.</p><h2 id="resultat" tabindex="-1">Résultat <a class="header-anchor" href="#resultat" aria-label="Permalink to &quot;Résultat&quot;">​</a></h2><p>Une fois la méthode profilage, la ou les ressources d&#39;intérêt et la granularité choisies, le code peut être profilé. Les résultats du profilage peuvent être présentés de différentes manières, selon ce que l&#39;on souhaite retirer de l&#39;analyse. Une possibilité consiste à <em>dessiner des courbes</em> qui vont permettre de voir des tendances qu&#39;il s&#39;agira éventuellement d&#39;améliorer en changeant le code, si elles sont trop mauvaises par rapport aux ressources d&#39;intérêt. Il est également possible d&#39;<em>extraire des données</em> avec comme objectif d&#39;identifier des portions de code à optimiser. On peut, par exemple, obtenir un tableau avec les fréquences d&#39;appels de toutes les fonctions du programme, celles qui sont appelées le plus souvent devant certainement être analysées plus en profondeur afin d&#39;identifier si elles doivent être optimisées ou non.</p>',15),a=[o];function n(u,l,d,p,m,c){return s(),t("div",null,a)}const h=e(i,[["render",n]]);export{g as __pageData,h as default};
