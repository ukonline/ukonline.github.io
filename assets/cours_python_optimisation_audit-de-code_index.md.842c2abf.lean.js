import{_ as o,o as r,c as d,x as e,a as t}from"./chunks/framework.0e180df0.js";const x=JSON.parse('{"title":"Audit de code","description":"","frontmatter":{},"headers":[],"relativePath":"cours/python/optimisation/audit-de-code/index.md"}'),s={name:"cours/python/optimisation/audit-de-code/index.md"},a=e("h1",{id:"audit-de-code",tabindex:"-1"},[t("Audit de code "),e("a",{class:"header-anchor",href:"#audit-de-code","aria-label":'Permalink to "Audit de code"'},"​")],-1),i=e("p",null,[t("Dans "),e("a",{href:"./../mesure-de-performance/"},"le chapitre précédent"),t(", différentes techniques et outils de mesure du temps d'exécution et de la consommation mémoire d'un programme, ou d'une partie de programme, ont été présentés. Comme précédemment rappelé, avant d'envisager une "),e("em",null,"optimisation"),t(" et de se lancer dans la modification du code d'un programme, il faut réaliser un "),e("em",null,"audit"),t(" de ce dernier. Il s'agit de retrouver les portions de code trop gourmandes en ressources, à savoir en temps processeur et en espace mémoire, lors des exécutions du programme. Ce chapitre présente des outils de "),e("em",null,"profilage"),t(" de programme et donne des pistes sur comment exploiter les rapports qu'ils produisent pour identifier les opportunités d'optimisation.")],-1),n=[a,i];function c(p,m,u,l,_,f){return r(),d("div",null,n)}const g=o(s,[["render",c]]);export{x as __pageData,g as default};
